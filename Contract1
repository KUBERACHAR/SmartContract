// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract LoanManagement {
    address public admin;

    constructor() {
        admin = msg.sender;
    }

    struct Borrower {
        string name;
        string idNumber;
        uint256 balance;
        bool registered;
    }

    struct Loan {
        address borrower;
        uint256 amount;
        uint256 interest;
        uint256 borrowerFee;
        uint256 lenderFee;
        bool approved;
        bool repaid;
    }

    struct Lender {
        string name;
        bool registered;
    }

    mapping(address => Borrower) public borrowers;
    mapping(address => Lender) public lenders;
    Loan[] public loanRequests;

    event BorrowerRegistered(address indexed borrower, string name);
    event LoanRequested(address indexed borrower, uint256 amount);
    event LoanApproved(uint256 indexed loanId, address indexed lender, uint256 interest, uint256 borrowerFee, uint256 lenderFee);
    event LoanRepaid(uint256 indexed loanId, uint256 totalPaid);

    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin can perform this action");
        _;
    }

    modifier onlyLender() {
        require(lenders[msg.sender].registered, "Only registered lenders allowed");
        _;
    }

    function registerBorrower(string memory _name, string memory _idNumber, uint256 _balance) public {
        borrowers[msg.sender] = Borrower(_name, _idNumber, _balance, true);
        emit BorrowerRegistered(msg.sender, _name);
    }

    function requestLoan(uint256 _amount) public {
        require(borrowers[msg.sender].registered, "Borrower not registered");
        require(borrowers[msg.sender].balance >= 1000, "Insufficient balance for eligibility");

        loanRequests.push(Loan(msg.sender, _amount, 0, 0, 0, false, false));
        emit LoanRequested(msg.sender, _amount);
    }

    function registerLender(string memory _name) public {
        lenders[msg.sender] = Lender(_name, true);
    }

    function approveLoan(uint256 _loanId) public onlyLender {
        require(_loanId < loanRequests.length, "Invalid loan ID");
        Loan storage loan = loanRequests[_loanId];
        require(!loan.approved, "Loan already approved");

        // Interest rate tiers
        if (loan.amount < 1_000_000) {
            loan.interest = (loan.amount * 2) / 100; // 2%
        } else if (loan.amount < 10_000_000) {
            loan.interest = (loan.amount * 15) / 1000; // 1.5%
        } else {
            loan.interest = (loan.amount * 1) / 100; // 1%
        }

        // Platform fees
        loan.borrowerFee = (loan.amount * 1) / 100; // 1% from borrower
        loan.lenderFee = (loan.amount * 1) / 100;   // 1% from lender

        loan.approved = true;

        emit LoanApproved(_loanId, msg.sender, loan.interest, loan.borrowerFee, loan.lenderFee);
    }

    function repayLoan(uint256 _loanId) public {
        require(_loanId < loanRequests.length, "Invalid loan ID");
        Loan storage loan = loanRequests[_loanId];
        require(msg.sender == loan.borrower, "Only borrower can repay");
        require(loan.approved, "Loan not approved");
        require(!loan.repaid, "Loan already repaid");

        uint256 totalRepayment = loan.amount + loan.interest + loan.borrowerFee;
        loan.repaid = true;

        emit LoanRepaid(_loanId, totalRepayment);
    }

    function getLoanRequests() public view returns (Loan[] memory) {
        return loanRequests;
    }
}
